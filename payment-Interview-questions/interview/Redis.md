# Redis
[TOC]

## 一、Redis
### 基础


#### 1、redis数据结构:
```
String 、Hash 、List 、Set 、Zset
```
#### 2、redis持久化:
```
rdb 
aof 
  aof重写机制:重写会根据重写策略或手动触发AOF重写
  1、bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。
  2、主进程fork出子进程执行重写操作，保证主进程不会阻塞。
  3、子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区 保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。
  4、1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。
  5、使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。
rdb+aof 
```
#### 3、reids分布式锁:
```
```
#### 4、reids高可用机制:
```
主从、哨兵、集群
```
#### 5、redis事务:
```
一组命令集合:
    multi:开启redis事务,置客户端为事务态
    exec:提交事务,执行从mutil到此命令前的命令队列,置客户端为非事务态
    discard:取消事务,置事务为非事务态
    watch:监视键值对,作用时如果事务提交exec时发现监视的监视对发生变化,事务将被取消
事务的保证:
    1、事务中的所有命令都是序列化且都是按顺序执行的。在一个客户端执行Redis事务的过程中，不会接收其他任何客户端对它发出的请求。这保证了这些命令是作为一个单独的独立操作执行的。
    2、所有的命令要么都被一起处理，要么全都没有被处理，所以Redis事务是原子的。EXEC会命令触发事务中所有命令的执行。当正在使用AOF时，Redis会使用一个简单的write 系统级调用来确保把事务写入到磁盘。但是，如果Redis服务崩溃，或者被系统管理员以某种强制的方式杀死，那么可能只有部分命令被写入到磁盘。Redis在重新启动时会检测这种情况，并报错，然后退出。使用redis-check-aof工具可以检查AOF，并移除那不完整的事务，使服务可以再次启动 
redis命令不支持回滚:只能检查语法错误,如果发生语法错误可以回滚. 
```
#### 6、主从数据同步:
```
增量同步、增量同步设计到的缓存区、快照同步、无盘复制(解决本地生存rdb文件)
```
#### 7、哨兵的工作原理:
```
1、每个 Sentinel 以 每秒钟 一次的频率，向它所知的 主服务器、从服务器 以及其他 Sentinel 实例 发送一个 PING 命令。
2、如果一个 实例（instance）距离 最后一次 有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为 主观下线。
3、如果一个 主服务器 被标记为 主观下线，那么正在监视这个主服务器的所有Sentinel节点，要以 每秒一次 的频率确认 主服务器 的确进入了 主观下线 状态。
4、如果一个 主服务器 被标记为 主观下线，并且有足够数量 的 Sentinel（至少要达到 配置文件 指定的数量）在指定的 时间范围 内同意这一判断，那么这个 主服务器 被标记为 客观下线。
5、在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率，向它已知的所有 主服务器 和 从服务器 发送 INFO 命令。当一个 主服务器 被 Sentinel 标记为 客观下线 时，Sentinel 向 下线主服务器 的所有 从服务器 发送 INFO 命令的频率，会从 10 秒一次改为 每秒一次。
6、Sentinel 和其他 Sentinel 协商 主节点 的状态，如果 主节点 处于 SDOWN 状态，则投票自动选出新的 主节点。将剩余的 从节点 指向 新的主节点 进行 数据复制。
7、当没有足够数量的 Sentinel 同意 主服务器 下线时， 主服务器 的 客观下线状态 就会被移除。当 主服务器 重新向 Sentinel 的 PING 命令返回 有效回复 时，主服务器 的 主观下线状态 就会被移除。
```

#### 8、哨兵主观下线(针对所有节点):
```
Sentinel 没有收到 目标节点的有效回复，则会判定 该节点 为 主观下线。
```

#### 9、哨兵客观下线(针对主节点):
```
Sentinel节点会通过命令，向其它Sentinel节点询问对该节点的状态判断。如果超过一半的节点判定主节点不可达，则该 Sentinel节点会判断主节点为客观下线。
```

#### 10、集群主观下线:
```
pfail （单个节点认为另一个节点下线，将它标记为pfail） 
```

#### 11、集群客观下线:
```
fail（节点彼此之间通过信息交换，大家达成共识了，都认为该节点下线，标记为fail）
```
#### 12、一致性hash算法:
```
一致性哈希算法在面对分布式缓存有着得天独厚的优势，因为它的产生就是为了解决分布式缓存扩容、缩容带来的缓存穿透问题。但现在一致性在分布式服务调用的负载算法竟然也提供了一致性哈希算法的实现 
一致性哈希算法的两个关键：
    1、顺时针选择节点。   可以使用TreeMap，一来具备排序功能，天然提供了相应的方法获取顺时针的一个元素。TreeMap 的 ceilingEntry()方法用于返回与大于或等于给定键元素(ele)的最小键元素链接的键值对。
    2、虚拟节点如何生成分散的哈希值.  生成分散的哈希值，通常可以基于md5来实现。
一致性哈希算法被“滥用”
    1、在Dubbo中为了实现客户端在服务调用时对服务提供者进行负载均衡，官方也提供了一致性哈希算法
    2、在RocketMQ集群消费模式时消费队列的负载均衡机制竟然也实现了一致性哈希算法
    但我觉得一致性哈希算法在这些领域完全无法发挥其他优势，比轮循、加权轮循、随机、加权随机算法等负载均衡算法相比，实现复杂，性能低下，运维管理复杂。

hash算法使用场景:
      分布式缓存负载均衡，特别是突出扩容、缩容能有效避免缓存穿透的问题。
  面试应对之策
      1、在面试过程中，遇到一致性哈希算的时候，尽量能从其使用场景：分布式缓存负载均衡，特别是突出扩容、缩容能有效避免缓存穿透的问题。同时需要阐述一致性哈希算法的缺陷以及其应对策略(虚拟节点)。 
      2、聊的差不多可以顺便提一下阅读过一致性哈希算法的源码：强调TreeMap与虚拟节点哈希值的生成方法。
      3、最后可以尝试引导面试官聊聊现在一致性哈希算法有点被滥用的嫌疑，在轻松愉快的讨论中与面试交流技术，面试官好评度蹭蹭往上涨。

```
#### 13、 如何保证数据库和缓存的数据的一致性,先删除缓存,后修改数据库的存在的问题:
```
先删除缓存,后更新数据库 1、起不到缓存作用 2、会存在脏数据(脏读)
```
#### 14、 redis中key的命中情况如何统计的,缓存起到了多大的情况:
```
 登陆服务器后使用info命令查看, 在Stats模块中keyspace_hits表示命中次数,keyspace_misses表示没有命中次数
```
#### 15、 redis热key怎么处理:
```
1、二级缓存,使用ehcache或者hashMap,在你发现热key以后，把热key加载到系统的JVM中。 针对这种热key请求，会直接从jvm中取，而不会走到redis层。
2、备份热key 不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。
```
#### 16、 缓存穿透:
```
key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
解决方案:
    1、最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
    2、另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
```
#### 17、 缓存击穿:
```
key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
```
#### 18、 缓存雪崩:
```
当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
```

#### 19、 redis跳表:
```
```
  




























