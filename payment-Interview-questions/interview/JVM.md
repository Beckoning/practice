# Java 基础面试题

## 一、JVM
### 基础

#### 1、运行时数据区都包含什么？
```
线程共享：堆、方法区
线程独享：程序计数器、虚拟机栈、本地方法栈
```

#### 2、垃圾回收算法？
```
标记清除、标记整理、复制算法、分代回收算法
```
#### 3、判断对象是否有效？
```
标记计数、可达性分析
```
#### 4、GC调优命令？
```
jstack: 查看线程的快照信息。 
jmap: 查询堆栈使用情况  
jstat:JVM运行时的状态信息，包括内存状态、垃圾回收等
``` 
#### 5、young gc触发条件？
``` 
对象直接在年轻代中的Eden区进行分配，如果Eden区域没有足够的空间，那么就会触发YGC（Minor GC）
``` 
#### 6、进入老年代的途径？
``` 
1、YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。
2、经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。
3、动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。
4、大对象：由-XX:PretenureSizeThreshold启动参数控制，若对象大小大于此值，就会绕过新生代, 直接在老年代中分配。
``` 
#### 7、FullGc触发条件？
``` 
1、老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC
2、空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC
3、Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC
4、System.gc() 或者Runtime.gc() 被显式调用时，触发FGC
``` 
#### 8、CMS执行流程？
``` 
初始标记(STW)、并发标记、并发预处理、重新标记(STW)、并发清理、并发重置 
``` 
#### 9、查看cpu标高命令？
``` 
1、通过 top命令查找到这个消耗CPU的进程号PID 8958
2、top -Hp pid   
3、printf '%x\n' PID (PID为上一步中获取到的线程号)转换成对应的16进制PID 5c7e 
4、使用jstack 获取对应的线程信息  jstack 8958 | grep 5c7e
5、jstack pid(进程pid)>stack.dump
``` 

#### 10、Class回收的条件？
``` 
注意：Class要被回收，条件比较苛刻，必须同时满足以下条件（仅仅是可以，不代表必然，因为还有一些参数可以进行控制）
1、该类所有实例都被回收啦，也就是在堆中不存在该类的任何实例
2、加载该类的ClassLoader已经被回收
3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
4、参数控制 -Xnoclassgc
    禁用类的垃圾收集器（GC）。这样可以节省一些GC时间，从而缩短了引用程序运行期间的中断时间
    当您-Xnoclassgc在启动时指定时，应用程序中的类对象在GC期间将保持不变，并且始终被认为是活动的，这可能导致更多的内存被永久占有，如果不谨慎使用，将抛出内存不足异常
拓展：废弃的常量和静态变量的回收就和Class回收的条件差不多
``` 
#### 11、安全点？
``` 
程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为"安全点"。
安全点的选择标准：【是否具有让程序长时间执行的特征】，因为大部分的指令的运行时间都很短，我们可以接受让这些指令执行完以后在进行垃圾回收，而如果某个
指令执行时间很长，程序如果让这些指令执行完再进行垃圾回收，这样就可能导致垃圾回收进行得不够及时。
因此 通常会将如【方法调用、循环跳转、异常跳转】等指令序列复用作为安全点。
```
#### 12、安全区域（如果线程Sleep或者Blocked，那么我们如果保证线程进入安全点）
```     
为了解决这种情况，【安全区域】这个概念就出现啦，安全区域是指：在一个代码片段内，对象之间的引用关系不会发生变化，那么在这个区域中的任何位置进行垃圾
回收都是没有问题的
在实际执行过程中，当线程金进入到安全区域时，会先将自己标示为进入Safe Region状态，那么当需要进行GC时，JVM会忽略已经进入到Safe Region的线程，
当线程要离开安全区域时，会判断GC是否完成，如果GC已经完成，则可以离开Safe Region，否则继续等待，直到接受到GC完成的信号。    
``` 

 
#### 13、 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？
``` 
1、抢占式中断：也就是中断所有的线程，然后再判断每个线程是否在安全点，如果不在，就恢复线程，让线程继续运行，直到跑到最近的安全点，这种方式目前已经
没有虚拟机在采用了。
2、主动式中断：当要发生GC时，设置一个标志位，然后其他线程运行到安全点时，先判断这个标志位，如果标志位的值表示此时需要进行GC，那么线程就停下来，
将自己中断挂起，否则继续运行。
``` 
#### 14、 什么对象可作为GCRoot的对象
``` 
java虚拟机栈中的引用对象
方法区中的类静态属性引用的对象（一般指被static修饰的对象，加载类的时候就加载到内存中）
方法区中常量引用的对象
本地方法栈中JNI（native方法）引用对象
``` 





      



      


     


    






















