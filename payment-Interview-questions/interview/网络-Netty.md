# Java 基础面试题
[TOC]

## 一、面向对象
### 基础


IO
   同步异步:客户端在请求数据的过程中，能否做其他事情。
   阻塞、非阻塞描述的是：客户端与服务端是否从头到尾始终都有一个持续连接，以至于占用了通道，不让其他客户端成功连接。
        分析阻塞:客户端和服务端都有一个线程,如果是阻塞那么只能又一个客户端链接上,等这个客户端断开链接其他客户端才能链接. 
        分析非阻塞:客户端和服务端都有一个线程,如果是阻塞那么可以有多个客户端连接上,然后服务端就循环处理这些客户端请求
   BIO(同步阻塞)
    定义：客户端在请求数据的过程中，保持一个连接，不能做其他事情。
    那么BIO存在两个问题：
        1、由于连接是双向的，“始终保持一个连接”，则说明，对于客户端和服务端而言，都需要一个线程来维护这个连接，如果服务端没有数据给客户端，则客户端需要一直等待，该连接也需要一直维持。假设一个连接需要5MB的内存，不考虑多任务的情况下，客户端总是要花费固定的5MB。那么对服务端，1个客户端建立连接则需要花5MB，10个就要50MB，1000个就要5GB。显然，阻塞给服务器带来的性能负担极大
        2、客户端不能做其他事情，只能等待该请求的完成，其本身的性能没有得到充分的释放，所以等待就是浪费时间。
   NIO(同步非阻塞)
    定义：客户端在请求数据的过程中，不用保持一个连接，不能做其他事情。
        客户端发送一个请求，并建立一个连接，服务端接收到了。如果服务端没有数据，就告知客户端“没有数据”；如果有数据，则返回数据。客户端接到了服务端回复的“没有数据”就断开连接，过了一段时间后，客户端重新问服务端是否有数据。服务器重复以上步骤(服务器不用重复创建线程)。客户端反复建立连接询问，如果没有数据则断开连接。这个过程称为“轮询”。NIO用轮询代替了始终保持一个连接。
    
  select的几大缺点：
    1、每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
    2、同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
    3、select支持的文件描述符数量太小了，默认是1024


  epoll的改进
    描述: epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。
    1、对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
    2、对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。
    3、对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

  相对于 select，epoll 有哪些改进？
     1、epoll 不再需要像 select 一样对 fd 集合进行轮询，也不需要在调用时将 fd 集合在用户态和内核态进行交换
     2、应用程序获得就绪 fd 的事件复杂度，epoll 是 O(1)，select 是 O(n)；
     3、select 最大支持约 1024 个 fd，epoll 支持 65535个；
     4、select 使用轮询模式检测就绪事件，epoll 采用通知方式，更加高效。    
   AIO(异步非阻塞)
     定义：客户端在请求数据的过程中，不用保持一个连接，可以做其他事情。
     AIO用了一个通知机制，其流程如下：
        客户端向服务端请求数据。服务端若有，则返回数据；若无，则告诉客户端“没有数据”。客户端收到“没有数据”的回复后，就做自己的其他事情。服务端有了数据之后，就主动通知客户端，并把数据返回去。
        需要提的是: 这里解决了连接的消耗，但是也必然引入了别的消耗。这里让客户端能先做别的事情，也肯定会带来新的麻烦。
        别的消耗是指: 服务端需要主动通知客户端，关于“通知”的业务逻辑肯定是需要消耗资源的。新的麻烦是指，客户端本来在做别的事情，突然前面的事情又插过来要做了，必然引入了一个多线程的协调工作
   


    






















