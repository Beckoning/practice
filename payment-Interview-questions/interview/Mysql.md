# MySql
[TOC]

## 一、索引
### 基础
[[阿里面试问的mysql]](https://zhuanlan.zhihu.com/p/73204847):

#### 1、mysql索引的数据结构？
```

```
#### 2、为什么使用B+树,与其他索引相比的优缺点？
```
1、数据都在通一层的叶子节点,非叶子节点只存储key,降低了树的高度(层级少、查询快、数据都在叶子节点所以查询速度稳定)
2、叶子节点从小到大有序排列,左边的尾数保存右边节点开始数据的指针(具备排序功能)
```
#### 2、不使用红黑树做索引的原因？
```
1、AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。
2、叶子节点从小到大有序排列,左边的尾数保存右边节点开始数据的指针(具备排序功能)
```
#### 3、使用红黑树效率低下的原因？
```
我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。
磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好
的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。2、叶子节点从小到大有序排列,左边的尾数保存右边节点开始
数据的指针(具备排序功能)
```
#### 4、解决效率低下的方案？
```
 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，
在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，
加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
```
#### 5、索引失效:
```
1、未按照指定的值类型查询,字符串类型 没有加引号
2、like时通配符在前
3、使用or查询
4、对索引列进行函数运算(MD5(card_code))
5、联合索引没有按照最左原则
6、使用了负向查询，可能会导致索引失效(NOT、!=、<>、!<、!>、NOT IN、NOT LIKE)
```
#### 6、哈希索引不适用的场景:
```
1、不支持范围查询 
2、不支持索引完成排序  
3、不支持联合索引的最左前缀匹配规则
```
#### 7、B+tree的叶子节点可以存放的数据:
```
1、ID对应的整条数据 --（聚簇索引）
2、主键ID，或者索引值（A,B字段建立联合索引 则叶子节点存放ID和A，B字段的值）--（非聚簇索引）
```

#### 8、回表查询(非聚簇索引):
```
通过非聚簇索引,查询出id然后在通过,id查询到数据(内部两次查询)
注意：覆盖索引索引查询不用回表查询.如联合索引为AB  select A,B from table where A= 'a' and B = 'b'
```
#### 8、索引下推技术(5.6版本优化):
```
people表中（zipcode，lastname，firstname）构成一个索引 
(sql SELECT * FROM people WHERE zipcode=‘95054’ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;): 
1、没有使用索引下推技术，则MySQL会通过zipcode='95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于
    lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。
2、使用索引下推技术--MYSQL首先会返回符合zipcode='95054’的索引，然后根据lastname LIKE '%etrunia%'筛选出符合条件的索引后再返回到MySQL服务端，
    然后MySQL服务端基于address LIKE '%Main Street%'来判断数据是否符合条件，这样返回给MySQL服务端的索引数又会减少

```
#### 8、为什么MySQL不建议使用delete删除数据？:
```
1、通过从InnoDB存储空间分布，delete对性能的影响可以看到，delete物理删除既不能释放磁盘空间，而且会产生大量的碎片，导致索引频繁分裂，
    影响SQL执行计划的稳定性；
2、同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作。
```
#### 9、B+树在进行范围查找时怎么处理？:
```
B+树的数据是按照顺序排列的,且每个数据页也有指针的关联,因此通过比较适合范围查找
```
#### 10、主从同步延迟原因？:
```
1、从库中 SQL 线程重放的过程是随机写盘的，并且 SQL 线程是单线程的，因此数据来不及重放的话就会导致主从延迟。
2、主库并发高会导致写操作不断写入 binlog，对于 SQL 线程说可能会应接不暇，也会产生主从延迟。
3、重放过程中如果遇到锁等待也是产生延迟的原因之一。
```
#### 11、主从延迟处理方案？:
```
MySQL 5.6版本以后通过并行复制的方式来解决 SQL 单线程产生的主从延迟问题。对于低版本来说，可以通过降低主库的并发来解决。如果对数据实时性要求比较严格的话，可以通过读主库来达到目的。  
```
#### 12、数据库的隔离机制？:
```
读未提交、读已提交、可重复读、可串行化
```
#### 13、数据库的隔离机制的实现:
```
读未提交：写的时候加行级共享锁,读事务不加锁 --存在脏读    
读已提交：写事务加行级排他锁,事务结束释放.读事务加行级共享锁,读完释放--(不等到整个事务结束后才释放) -- 存在不可重复读
可重复读：写事务加行级排他锁,读事务加行级共享锁,都持续到事务结束才释放(确保整个事务中写就是写，读就是读，整个事务读完之后才可以写) --存在幻读
```
#### 14、幻读的解决:
```
当前读:读取的是记录的最新版本,读取时还要保证其他事务不能修改当前记录,会带读取的记录进行加锁。如:加锁了读select * from table where id>3 ,锁住的就是id=3这条记录及id>3这条区间范围,  索引记录之间的范围，避免范围内插入记录，避免产生幻读行记录(使用间隙锁实现)
普通读:普通读是不加锁的读，解决幻读的手段是MVCC。MVCC会给每行元组加一些辅助字段，记录创建版本号和删除版本号。而每个事务在启动的时候，都有一个唯一的递增的版本号。开启新事务，事务版本号就会递增。
```
#### 15、为什么分页查询,后续效率越来越慢:
```
1、数据存放可能跨数据页
2、执行sql有count(*)操作 可以换成上下页查询,进行不要做统计
```
#### 16、数据库悲观锁、乐观锁,优缺点:
```
悲观锁:开始就加锁,并发性不高
乐观锁:CAS、版本号  缺点:1、CAS存在ABA问题 2、自旋时间比较长 3、只能保证一个共享变量的原子操作
```
#### 17、分库分表的策略(每月分表、单分100张表)有什么优势、或者问题:
```
单分100张表,不会出现热点数据,但是后续查询(根据时间、人维度)查询麻烦
单月分表(后续统计每月的记录信息方便)但是每个月可能会出现热点数据
```

#### 18、分库分表,后续扩容:
```
1、通过修改订单号的生成策略,然后选择不用的表、库 然后达到切流的方式
2、通过hash一致性算法来达到动态扩容、但是存在数据清洗,需要把id值移动到其他的数据表、库中  
```
#### 19、联合索引在B+树上的存储结构及数据查找方式 [[参考]](https://juejin.cn/post/6844904073955639304):
```
```
#### 20、MySQL 分库分表支持服务无限扩容吗？ [[参考]](https://blog.csdn.net/wanghao112956/article/details/90695814):
```
```








    







      












