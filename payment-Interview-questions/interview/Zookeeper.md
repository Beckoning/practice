
# Zookeeper

## 一、Zookeeper
### 基础

#### 1、基于Zookeeper实现分布式锁[[参考]](https://blog.csdn.net/wuzhiwei549/article/details/80692278)
```
可以作为分布式锁的原理：
  ZooKeeper是一个分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。
流程：
    1、创建一个目录mulock
    2、线程A想获取锁就在mulock目录下创建临时顺序节点
    3、获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序最小，获取锁。
    4、线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点。
    5、线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是这获得锁    
```

#### 2、Redis分布式锁和Zookeeper分布式锁的对比
```
第一次获取锁失败
    Redis分布式锁，需要自己不断的尝试获取锁，比较消耗性能
    Zookeeper分布式锁，获取不到锁，注册监听即可，不需要不断主动尝试获取锁，性能开销比较小
获取锁的客户端出现Bug挂了
    Redis如果获取锁的客户端出现问题，那么只能等待超时时间之后才能释放锁
    Zookeeper创建的是临时znode，只要客户端挂了，znode就没啦，此时就自动释放锁  
频繁的加锁、解锁
    Redis是内存形的数据库，因此性能比较高
    Zookeeper需要频繁的申请加锁（创建目录）、解锁（删除目录），对于ZK集群的压力比较大
```
#### 3、Zookeeper如果感应到服务上下线
```
zookeeper提供了"心跳检查"功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个socket长连接），如果长期没有响应，服务注册中心就认为
该服务提供者已经"挂了"，并将其剔除，比如100.100.0.237这台机器如果宕机了，那么zookeeper上的路径下就会删除100.100.0.237这台机器

服务消费者会监听相应路径（/HelloWorldService/1.0.0）,一旦路径上的数据有任务变化（增加或减少），zookeeper都会通知服务消费方、服务提供者地址列表已经发生改变，从而进行更新
```




























